using Discord;
using Discord.WebSocket;
using System.Text;
using System.Collections.Concurrent;

namespace WorkerService1.Discord.Services
{
    public class ProductNotificationService
    {
        private static readonly ConcurrentDictionary<string, CancellationTokenSource> _pendingCreations = new();
        private static readonly ConcurrentDictionary<string, CancellationTokenSource> _pendingUpdates = new();
        private static readonly ConcurrentDictionary<string, CancellationTokenSource> _pendingDeletions = new();
        
        private readonly ILogger<ProductNotificationService> _logger;
        private readonly IConfiguration _configuration;
        private readonly DiscordSocketClient _client;

        public ProductNotificationService(ILogger<ProductNotificationService> logger, IConfiguration configuration, DiscordSocketClient client)
        {
            _logger = logger;
            _configuration = configuration;
            _client = client;
        }

        public Task HandleProductCreated(Stripe.Product product)
        {
            _logger.LogInformation($"Evento CREATED recebido para {product.Id}. Tem prioridade sobre 'updated'.");
            
            // Cancela qualquer notifica√ß√£o de 'updated' que possa ter chegado antes por engano.
            if (_pendingUpdates.TryRemove(product.Id, out var cts))
            {
                _logger.LogWarning($"Cancelando notifica√ß√£o de 'updated' pendente para dar lugar √† de 'created'.");
                cts.Cancel();
            }

            // Inicia a notifica√ß√£o de 'created' (que agora n√£o ser√° cancelada por um 'updated').
            return StartDelayedNotification(product, "created", TimeSpan.FromSeconds(5), _pendingCreations);
        }

        public Task HandleProductDeleted(Stripe.Product product)
        {
            _logger.LogInformation($"Evento DELETED recebido para {product.Id}. Tem prioridade m√°xima.");

            // Cancela QUALQUER notifica√ß√£o pendente (created ou updated).
            if (_pendingUpdates.TryRemove(product.Id, out var cts2)) cts2.Cancel();

            // AGORA, em vez de agir imediatamente, ele tamb√©m inicia a espera de 5 segundos.
            return StartDelayedNotification(product, "deleted", TimeSpan.FromSeconds(5), _pendingDeletions);
        }

        public Task HandleProductUpdated(Stripe.Product product)
        {
            // --- L√ìGICA DE PRIORIDADE ---
            // Se uma notifica√ß√£o de 'created' j√° est√° na fila, este 'updated' √© provavelmente
            // uma edi√ß√£o r√°pida e deve ser IGNORADO para n√£o cancelar a mensagem de cria√ß√£o.
            if (_pendingCreations.ContainsKey(product.Id))
            {
                _logger.LogInformation($"Ignorando evento 'updated' para {product.Id} porque uma notifica√ß√£o de 'created' j√° est√° pendente.");
                return Task.CompletedTask;
            }

            var eventType = !product.Active ? "archived" : "updated";
            return StartDelayedNotification(product, eventType, TimeSpan.FromSeconds(5), _pendingUpdates);
        }

        private Task StartDelayedNotification(Stripe.Product product, string eventType, TimeSpan delay, ConcurrentDictionary<string, CancellationTokenSource> pendingDictionary)
        {
            _logger.LogInformation($"Iniciando espera de {delay.TotalSeconds}s para o evento '{eventType}' do produto {product.Id}.");

            var cts = new CancellationTokenSource();
            
            // Cancela qualquer tarefa antiga DO MESMO TIPO e adiciona a nova
            if (pendingDictionary.TryGetValue(product.Id, out var oldCts))
            {
                oldCts.Cancel();
            }
            pendingDictionary[product.Id] = cts;

            Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(delay, cts.Token);
                    _logger.LogInformation($"Tempo de espera para '{eventType}' ({product.Id}) expirou. Processando...");
                    await ProcessProductEvent(product, eventType);
                }
                catch (TaskCanceledException)
                {
                    _logger.LogInformation($"A notifica√ß√£o de '{eventType}' para {product.Id} foi cancelada.");
                }
                finally
                {
                    pendingDictionary.TryRemove(new KeyValuePair<string, CancellationTokenSource>(product.Id, cts));
                }
            });

            return Task.CompletedTask;
        }
        
        private async Task ProcessProductEvent(Stripe.Product product, string eventType)
        {
            _logger.LogInformation($"Processando evento de produto '{eventType}' para: {product.Name}");
            try
            {
                var activePlans = await GetActivePlans();
                await SendActivePlansToDiscord(activePlans, product, eventType);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ocorreu uma exce√ß√£o inesperada ao processar o evento do produto.");
            }
        }

        private async Task<List<Stripe.Price>> GetActivePlans()
        {
            _logger.LogInformation("Buscando planos ativos do Stripe...");
            var options = new Stripe.PriceListOptions { Active = true, Limit = 100 };
            var prices = await new Stripe.PriceService().ListAsync(options);
            _logger.LogInformation("{Count} planos ativos encontrados.", prices.Data.Count);
            return prices.Data.ToList();
        }

        // --- M√âTODO PREENCHIDO COM A L√ìGICA E OS LOGS ---
        private async Task SendActivePlansToDiscord(List<Stripe.Price> activePlans, Stripe.Product product, string eventType)
        {
            _logger.LogInformation("Preparando para enviar mensagem de notifica√ß√£o para o Discord...");
            
            // --- VERIFICA√á√ïES ---
            var channelIdStr = "1420206249508601857"; // Canal de Notifica√ß√µes, verifique se este ID est√° correto.
            if (!ulong.TryParse(channelIdStr, out var channelId))
            {
                _logger.LogError("ID do canal de notifica√ß√£o √© inv√°lido: {ChannelId}", channelIdStr);
                return;
            }

            var guildIdStr = _configuration["Discord:GuildId"];
            if (!ulong.TryParse(guildIdStr, out var guildId))
            {
                _logger.LogError("DiscordGuildId n√£o configurado ou √© inv√°lido.");
                return;
            }
            _logger.LogInformation("Configura√ß√µes de Guild ID ({guildId}) e Channel ID ({channelId}) lidas.", guildId, channelId);

            var guild = _client?.GetGuild(guildId);
            if (guild == null)
            {
                _logger.LogError("N√£o foi poss√≠vel encontrar o Servidor (Guild) com o ID: {GuildId}. Verifique se o bot est√° no servidor.", guildId);
                return;
            }
            _logger.LogInformation("Servidor (Guild) '{GuildName}' encontrado.", guild.Name);

            var channel = guild.GetTextChannel(channelId);
            if (channel == null)
            {
                _logger.LogError("N√£o foi poss√≠vel encontrar o Canal de Texto com o ID: {ChannelId} no servidor {GuildName}", channelId, guild.Name);
                return;
            }
            _logger.LogInformation("Canal de destino '#{ChannelName}' encontrado.", channel.Name);

            // --- L√ìGICA DO EMBED ---
            var (title, color) = eventType switch
            {
                "created" => ("üÜï Novo Produto Criado no Stripe!", Color.Green),
                "deleted" => ("üóëÔ∏è Produto Deletado no Stripe!", Color.Red),
                "archived" => ("üì¶ Produto Arquivado no Stripe!", Color.Orange),
                "updated" => ("üìù Produto Atualizado no Stripe!", Color.Blue),
                _ => ("üìù Produto Atualizado no Stripe!", Color.Gold)
            };

            var embedBuilder = new EmbedBuilder()
                .WithTitle(title)
                .WithDescription($"**Produto:** {product.Name}\n")
                .WithColor(color)
                .WithCurrentTimestamp()
                .WithFooter($"ID do Produto: {product.Id}");
            
            // 1. Crie um StringBuilder para montar a se√ß√£o de detalhes.
            var details = new StringBuilder();
            details.AppendLine("\n");
            // 2. Verifique e adicione cada metadado, um por um.
            if (product.Metadata.TryGetValue("> aventura", out var aventura))
            {
                details.AppendLine($"> **Aventura:** {aventura}");
            }
            if (product.Metadata.TryGetValue("> mestre", out var mestre))
            {
                details.AppendLine($"> **Mestre:** {mestre}");
            }
            if (product.Metadata.TryGetValue("> vagas", out var vagas))
            {
                details.AppendLine($"> **Vagas Dispon√≠veis:** {vagas}");
            }
            if (product.Metadata.TryGetValue("> horas", out var horas))
            {
                details.AppendLine($"> **Dura√ß√£o:** {horas}");
            }
            if (product.Metadata.TryGetValue("> horario", out var horario))
            {
                details.AppendLine($"> **Hor√°rio:** {horario}");
            }

            // 3. Adicione a descri√ß√£o do produto (campo padr√£o do Stripe)
            if (!string.IsNullOrEmpty(product.Description))
            {
                details.AppendLine($"\n> **Descri√ß√£o:**\n{product.Description}");
            }

            // 4. Se encontramos algum detalhe, adicionamos o campo ao embed.
            if (details.Length > 0)
            {
                embedBuilder.AddField("üìã Detalhes", details.ToString());
            }
            
            // 1. Verificamos se a lista de imagens n√£o est√° vazia.
            if (product.Images.Any())
            {
                // 2. Pegamos a primeira imagem da lista e a usamos como a imagem principal do Embed.
                embedBuilder.WithImageUrl(product.Images.First());
            }

            // --- ENVIO DA MENSAGEM ---
            try
            {
                _logger.LogInformation("Enviando a mensagem para o Discord...");
                await channel.SendMessageAsync(embed: embedBuilder.Build());
                _logger.LogInformation("SUCESSO! Mensagem de notifica√ß√£o enviada para o canal #{ChannelName}.", channel.Name);
            }
            catch(Exception ex)
            {
                _logger.LogError(ex, "!!! FALHA AO ENVIAR MENSAGEM PARA O DISCORD !!! Causa prov√°vel: O bot n√£o tem permiss√£o para 'Enviar Mensagens' ou 'Anexar Links' neste canal.");
            }
        }
        
        private string GetPlanMappingName(string priceId)
        {
            var planMappingSection = _configuration.GetSection("PlanMapping");
            return planMappingSection.GetChildren().FirstOrDefault(x => x.Value == priceId)?.Key ?? string.Empty;
        }
    }
}